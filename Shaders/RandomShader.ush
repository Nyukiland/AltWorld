#pragma once
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

struct Tuto
{
	static float3 Palette(float T)
	{
		float3 A = float3(0.5, 0.5, 0.5);
		float3 B = float3(0.5, 0.5, 0.5);
		float3 C = float3(1.0, 1.0, 1.0);
		float3 D = float3(0.263, 0.416, 0.557);

		return A + B * cos(6.28318 * (C * T + D));
	}

	static float4 CircleFractalMove(float2 FragCoord, float Time, float2 Resolution)
	{
		float2 UV = (FragCoord * 2.0 - 1.0) * float2(Resolution.x / Resolution.y, 1);
		float2 UV0 = UV;

		float3 FinalColor = 0;

		[unroll]
		for (int i = 0; i < 8; i++)
		{
			UV = frac(UV * 1.5 + 1.0) - 0.5;

			float Dist = length(UV) * exp(saturate(-length(UV0)));

			float3 Col = Palette(length(UV0) + i * 0.4 + Time * 0.4);

			Dist = sin(Dist * 8.0 + Time) * 0.125;
			Dist = abs(Dist);

			Dist = max(Dist, 1e-5);
			Dist = pow(0.01 / Dist, 1.2);

			FinalColor += Col * Dist;
		}

		return float4(FinalColor, 1);
	}
};

struct Noise3D
{
	static float3 Hash33(float3 P)
	{
		P = frac(P * 0.3183099 + float3(0.1, 0.2, 0.3));
		P *= 17.0;
		return frac(P.x * P.y * P.z * (P + 0.1));
	}

	static float GradientNoise(float3 P)
	{
		float3 Pi = floor(P);
		float3 Pf = frac(P);

		float3 U = Pf * Pf * (3.0 - 2.0 * Pf);

		return lerp(
			lerp(
				lerp(dot(Hash33(Pi + float3(0, 0, 0)) * 2.0 - 1.0, Pf - float3(0, 0, 0)),
				     dot(Hash33(Pi + float3(1, 0, 0)) * 2.0 - 1.0, Pf - float3(1, 0, 0)), U.x),
				lerp(dot(Hash33(Pi + float3(0, 1, 0)) * 2.0 - 1.0, Pf - float3(0, 1, 0)),
				     dot(Hash33(Pi + float3(1, 1, 0)) * 2.0 - 1.0, Pf - float3(1, 1, 0)), U.x), U.y),
			lerp(
				lerp(dot(Hash33(Pi + float3(0, 0, 1)) * 2.0 - 1.0, Pf - float3(0, 0, 1)),
				     dot(Hash33(Pi + float3(1, 0, 1)) * 2.0 - 1.0, Pf - float3(1, 0, 1)), U.x),
				lerp(dot(Hash33(Pi + float3(0, 1, 1)) * 2.0 - 1.0, Pf - float3(0, 1, 1)),
				     dot(Hash33(Pi + float3(1, 1, 1)) * 2.0 - 1.0, Pf - float3(1, 1, 1)), U.x), U.y),
			U.z);
	}
	
	static float ClassicNoise(float3 P, float Frequency, int Octaves, float Lacunarity, float Gain)
	{
		float Amplitude = 1.0;
		float Total = 0.0;

		for (int I = 0; I < Octaves; I++)
		{
			Total += GradientNoise(P * Frequency) * Amplitude;
			P *= Lacunarity;
			Amplitude *= Gain;
		}

		return Total;
	}
	
	static float RaymarchNoise(float3 Origin, float3 Direction, int Steps, float StepSize, float Frequency, float Density, float Distortion)
	{
		float Accum = 0.0;
		float3 P = Origin;

		for (int I = 0; I < Steps; I++)
		{
			float3 Distorted = P + GradientNoise(P * Frequency) * Distortion;
			float N = ClassicNoise(Distorted, Frequency, 4, 2.0, 0.5);

			Accum += saturate(N) * Density;
			P += Direction * StepSize;
		}

		return Accum;
	}
};

struct SdfNoise
{
	static float Hash(float3 P)
	{
		P = frac(P * 0.3183099 + 0.1);
		return frac(P.x * P.y * P.z * (P.x + P.y + P.z));
	}

	static float Noise(float3 P)
	{
		float3 I = floor(P);
		float3 F = frac(P);
		float3 U = F * F * (3.0 - 2.0 * F);

		float N = 0.0;

		for (int X = 0; X < 2; X++)
		{
			for (int Y = 0; Y < 2; Y++)
			{
				for (int Z = 0; Z < 2; Z++)
				{
					float3 O = float3(X, Y, Z);
					float3 H = Hash(I + O);
					float3 D = (O - F);

					float W = dot(H * 2.0 - 1.0, D);
					float S = 
						  (X == 0 ? (1.0 - U.x) : U.x)
						* (Y == 0 ? (1.0 - U.y) : U.y)
						* (Z == 0 ? (1.0 - U.z) : U.z);

					N += W * S;
				}
			}
		}

		return N;
	}

	static float SdfNoiseValue(float3 P, float Frequency, float WarpStrength, float Amplitude)
	{
		float3 Warp = Noise(P * Frequency) * WarpStrength;
		float D = Noise(P * Frequency + Warp);

		return abs(D) * Amplitude;
	}
};

struct CurlNoise
{
	static float Hash(float3 P)
	{
		P = frac(P * 0.3183099 + 0.1);
		return frac(dot(P, float3(7.0, 157.0, 113.0)) * 0.00001);
	}

	static float Noise(float3 P)
	{
		float3 I = floor(P);
		float3 F = frac(P);
		float3 U = F * F * (3.0 - 2.0 * F);

		float N = 0.0;

		for (int X = 0; X < 2; X++)
		{
			for (int Y = 0; Y < 2; Y++)
			{
				for (int Z = 0; Z < 2; Z++)
				{
					float3 O = float3(X, Y, Z);
					float H = Hash(I + O);

					float W = 
						  (X == 0 ? (1.0 - U.x) : U.x)
						* (Y == 0 ? (1.0 - U.y) : U.y)
						* (Z == 0 ? (1.0 - U.z) : U.z);

					N += H * W;
				}
			}
		}

		return N;
	}

	static float3 Curl(float3 P)
	{
		float Eps = 0.1;

		float Dx1 = Noise(P + float3(Eps, 0, 0));
		float Dx2 = Noise(P - float3(Eps, 0, 0));
		float Dy1 = Noise(P + float3(0, Eps, 0));
		float Dy2 = Noise(P - float3(0, Eps, 0));
		float Dz1 = Noise(P + float3(0, 0, Eps));
		float Dz2 = Noise(P - float3(0, 0, Eps));

		float3 D = float3(
			Dy1 - Dy2 - Dz1 + Dz2,
			Dz1 - Dz2 - Dx1 + Dx2,
			Dx1 - Dx2 - Dy1 + Dy2
		);

		return normalize(D);
	}

	static float3 CurlNoiseFlow(float3 P, float Frequency, float Strength)
	{
		float3 C = Curl(P * Frequency);
		return C * Strength;
	}
};

struct Kernel
{
	static float3x3 Identity() 
	{ 
		return float3x3(
			0,0,0,
			0,1,0,
			0,0,0); 
	}

	static float3x3 Edge0() 
	{ 
		return float3x3(
			1,0,-1,
			0,0,0,
			-1,0,1);
	}

	static float3x3 Edge1() 
	{ 
		return float3x3(
			0,1,0,
			1,-4,1,
			0,1,0); 	
	}

	static float3x3 Edge2() 
	{ 
		return float3x3(
			-1,-1,-1,
			-1, 8,-1,
			-1,-1,-1); 
	}

	static float3x3 Sharpen() 
	{ 
		return float3x3(
			0,-1,0,
			-1,5,-1,
			0,-1,0); 
	}

	static float3x3 BoxBlur() 
	{ 
		return float3x3(
			1,1,1,
			1,1,1,
			1,1,1) * 0.1111; 
	}

	static float3x3 GaussianBlur() 
	{ 
		return float3x3(
			1,2,1,
			2,4,2,
			1,2,1) * 0.0625; 
	}

	static float3x3 Emboss() 
	{ 
		return float3x3(
			-2,-1,0,
			-1, 1,1,
		 	0, 1,2); 
	}

	static float2 KernelOffset(int Index, float2 TexelSize)
	{
		const float2 Offsets[9] =
		{
			float2(-1,-1), float2(0,-1), float2(1,-1),
			float2(-1, 0), float2(0, 0), float2(1, 0),
			float2(-1, 1), float2(0, 1), float2(1, 1)
		};

		return Offsets[Index] * TexelSize;
	}

	static void Region3x3(Texture2D Tex, float2 UV, float2 TexelSize,
		out float3x3 R, out float3x3 G, out float3x3 B)
	{
		float3 Values[9];

		for (int I = 0; I < 9; I++)
		{
			float3 C = Tex.SampleLevel(TexSampler, UV + KernelOffset(I, TexelSize), 0).rgb;
			Values[I] = C;
		}

		R = float3x3(
			Values[0].r, Values[1].r, Values[2].r,
			Values[3].r, Values[4].r, Values[5].r,
			Values[6].r, Values[7].r, Values[8].r);

		G = float3x3(
			Values[0].g, Values[1].g, Values[2].g,
			Values[3].g, Values[4].g, Values[5].g,
			Values[6].g, Values[7].g, Values[8].g);

		B = float3x3(
			Values[0].b, Values[1].b, Values[2].b,
			Values[3].b, Values[4].b, Values[5].b,
			Values[6].b, Values[7].b, Values[8].b);
	}

	static float3 Convolution(float3x3 Matrix, Texture2D Tex, float2 UV, float2 Resolution)
	{
		float2 TexelSize = 1.0 / Resolution;

		float3x3 R, G, B;
		Region3x3(Tex, UV, TexelSize, R, G, B);

		float3 OutCol = 0;

		for (int Y = 0; Y < 3; Y++)
		{
			for (int X = 0; X < 3; X++)
			{
				OutCol.r += R[Y][X] * Matrix[Y][X];
				OutCol.g += G[Y][X] * Matrix[Y][X];
				OutCol.b += B[Y][X] * Matrix[Y][X];
			}
		}

		return OutCol;
	}
};

struct Mandelbrot
{
	static float2 SquareImaginary(float2 number)
	{
		return float2(
			pow(number.x,2)-pow(number.y,2),
			2*number.x*number.y
		);
	}
	
	static float3 MandelbrotFunc(float2 UV, float Initial, float Step)
	{
		float2 u = Initial;
		float2 c = UV;

		int i = 0;
		for (i = 0; i < 100; i++)
		{
			u = SquareImaginary(u) + c;
			if (length(u) > 2) break;
		}

		float brightness = 1 - float(i)/Step;
		return i == 100 ? float3(0,0,0) : float3(brightness, brightness,brightness);
	}
};