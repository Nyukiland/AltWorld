#pragma once
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

struct Tuto
{
	static float3 Palette(float T)
	{
		float3 A = float3(0.5, 0.5, 0.5);
		float3 B = float3(0.5, 0.5, 0.5);
		float3 C = float3(1.0, 1.0, 1.0);
		float3 D = float3(0.263, 0.416, 0.557);

		return A + B * cos(6.28318 * (C * T + D));
	}

	static float4 CircleFractalMove(float2 FragCoord, float Time, float2 Resolution)
	{
		float2 UV = (FragCoord * 2.0 - 1.0) * float2(Resolution.x / Resolution.y, 1);
		float2 UV0 = UV;

		float3 FinalColor = 0;

		[unroll]
		for (int i = 0; i < 8; i++)
		{
			UV = frac(UV * 1.5 + 1.0) - 0.5;

			float Dist = length(UV) * exp(saturate(-length(UV0)));

			float3 Col = Palette(length(UV0) + i * 0.4 + Time * 0.4);

			Dist = sin(Dist * 8.0 + Time) * 0.125;
			Dist = abs(Dist);

			Dist = max(Dist, 1e-5);
			Dist = pow(0.01 / Dist, 1.2);

			FinalColor += Col * Dist;
		}

		return float4(FinalColor, 1);
	}
};

struct Noise3D
{
	static float3 Hash33(float3 P)
	{
		P = frac(P * 0.3183099 + float3(0.1, 0.2, 0.3));
		P *= 17.0;
		return frac(P.x * P.y * P.z * (P + 0.1));
	}

	static float GradientNoise(float3 P)
	{
		float3 Pi = floor(P);
		float3 Pf = frac(P);

		float3 U = Pf * Pf * (3.0 - 2.0 * Pf);

		return lerp(
			lerp(
				lerp(dot(Hash33(Pi + float3(0, 0, 0)) * 2.0 - 1.0, Pf - float3(0, 0, 0)),
				     dot(Hash33(Pi + float3(1, 0, 0)) * 2.0 - 1.0, Pf - float3(1, 0, 0)), U.x),
				lerp(dot(Hash33(Pi + float3(0, 1, 0)) * 2.0 - 1.0, Pf - float3(0, 1, 0)),
				     dot(Hash33(Pi + float3(1, 1, 0)) * 2.0 - 1.0, Pf - float3(1, 1, 0)), U.x), U.y),
			lerp(
				lerp(dot(Hash33(Pi + float3(0, 0, 1)) * 2.0 - 1.0, Pf - float3(0, 0, 1)),
				     dot(Hash33(Pi + float3(1, 0, 1)) * 2.0 - 1.0, Pf - float3(1, 0, 1)), U.x),
				lerp(dot(Hash33(Pi + float3(0, 1, 1)) * 2.0 - 1.0, Pf - float3(0, 1, 1)),
				     dot(Hash33(Pi + float3(1, 1, 1)) * 2.0 - 1.0, Pf - float3(1, 1, 1)), U.x), U.y),
			U.z);
	}
	
	static float ClassicNoise(float3 P, float Frequency, int Octaves, float Lacunarity, float Gain)
	{
		float Amplitude = 1.0;
		float Total = 0.0;

		for (int I = 0; I < Octaves; I++)
		{
			Total += GradientNoise(P * Frequency) * Amplitude;
			P *= Lacunarity;
			Amplitude *= Gain;
		}

		return Total;
	}
	
	static float RaymarchNoise(float3 Origin, float3 Direction, int Steps, float StepSize, float Frequency, float Density, float Distortion)
	{
		float Accum = 0.0;
		float3 P = Origin;

		for (int I = 0; I < Steps; I++)
		{
			float3 Distorted = P + GradientNoise(P * Frequency) * Distortion;
			float N = ClassicNoise(Distorted, Frequency, 4, 2.0, 0.5);

			Accum += saturate(N) * Density;
			P += Direction * StepSize;
		}

		return Accum;
	}
};

struct SdfNoise
{
	static float Hash(float3 P)
	{
		P = frac(P * 0.3183099 + 0.1);
		return frac(P.x * P.y * P.z * (P.x + P.y + P.z));
	}

	static float Noise(float3 P)
	{
		float3 I = floor(P);
		float3 F = frac(P);
		float3 U = F * F * (3.0 - 2.0 * F);

		float N = 0.0;

		for (int X = 0; X < 2; X++)
		{
			for (int Y = 0; Y < 2; Y++)
			{
				for (int Z = 0; Z < 2; Z++)
				{
					float3 O = float3(X, Y, Z);
					float3 H = Hash(I + O);
					float3 D = (O - F);

					float W = dot(H * 2.0 - 1.0, D);
					float S = 
						  (X == 0 ? (1.0 - U.x) : U.x)
						* (Y == 0 ? (1.0 - U.y) : U.y)
						* (Z == 0 ? (1.0 - U.z) : U.z);

					N += W * S;
				}
			}
		}

		return N;
	}

	static float SdfNoiseValue(float3 P, float Frequency, float WarpStrength, float Amplitude)
	{
		float3 Warp = Noise(P * Frequency) * WarpStrength;
		float D = Noise(P * Frequency + Warp);

		return abs(D) * Amplitude;
	}
};

struct CurlNoise
{
	static float Hash(float3 P)
	{
		P = frac(P * 0.3183099 + 0.1);
		return frac(dot(P, float3(7.0, 157.0, 113.0)) * 0.00001);
	}

	static float Noise(float3 P)
	{
		float3 I = floor(P);
		float3 F = frac(P);
		float3 U = F * F * (3.0 - 2.0 * F);

		float N = 0.0;

		for (int X = 0; X < 2; X++)
		{
			for (int Y = 0; Y < 2; Y++)
			{
				for (int Z = 0; Z < 2; Z++)
				{
					float3 O = float3(X, Y, Z);
					float H = Hash(I + O);

					float W = 
						  (X == 0 ? (1.0 - U.x) : U.x)
						* (Y == 0 ? (1.0 - U.y) : U.y)
						* (Z == 0 ? (1.0 - U.z) : U.z);

					N += H * W;
				}
			}
		}

		return N;
	}

	static float3 Curl(float3 P)
	{
		float Eps = 0.1;

		float Dx1 = Noise(P + float3(Eps, 0, 0));
		float Dx2 = Noise(P - float3(Eps, 0, 0));
		float Dy1 = Noise(P + float3(0, Eps, 0));
		float Dy2 = Noise(P - float3(0, Eps, 0));
		float Dz1 = Noise(P + float3(0, 0, Eps));
		float Dz2 = Noise(P - float3(0, 0, Eps));

		float3 D = float3(
			Dy1 - Dy2 - Dz1 + Dz2,
			Dz1 - Dz2 - Dx1 + Dx2,
			Dx1 - Dx2 - Dy1 + Dy2
		);

		return normalize(D);
	}

	static float3 CurlNoiseFlow(float3 P, float Frequency, float Strength)
	{
		float3 C = Curl(P * Frequency);
		return C * Strength;
	}
};
